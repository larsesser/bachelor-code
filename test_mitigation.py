from typing import NamedTuple

from qiskit import transpile
from qiskit.providers.aer.backends.aerbackend import AerBackend
from qiskit.result.result import Result
from sympy import Expr, S

from expectation_value import projective_measurement
from noise import ErrorProbabilities
from util import init_random_state, random_angles
from w import OrderedOperator, relevant_operators, w_inverse_element, w_matrix


class BenchmarkResult(NamedTuple):
    """The result of one call of the benchmark_mitigation procedure.

    This contains the expectation values for <psi|O|psi>, where O is a given operator
    and |psi> is a random state generated by the benchmark_mitigation procedure.
    """
    noiseless: float
    noisy: float
    corrected: float


def benchmark_mitigation(
        operator: OrderedOperator,
        noiseless_backend: AerBackend,
        noisy_backend: AerBackend,
        error_probabilities: ErrorProbabilities
) -> BenchmarkResult:
    """Produce some data to benchmark the error correction.

    We want to compare three cases:
        1. the (QM) expectation of the given operator, measured on a noiseless backend
        2. the (QM) expectation of the given operator, measured on a noisy backend
        3. the error corrected operator, measured on a noisy backend.

    For this, we measure the given state in the computational basis on a noisless and a
    noisy device.

    The first case is obtained by calculating the expectation value with respect to the
    given operator from the noiseless result, the second one from the noisy result.
    To obtain the third one, the measurements are interpreted with respect to the
    correcting operators and weights obtained by the w matrix.

    :param operator: the operator which expectation value should be determined.
    :param noiseless_backend: the noiseless backend for fact-checking the correction.
    :param noisy_backend: the noisy backend to perform the actual measurements.
    :param error_probabilities: the bit-flip probabilities of each qubit.
    """
    # prepare a random state |psi> to be measured
    state = init_random_state(operator.N, angles=random_angles(operator.N))
    state.measure_all()

    # 1. measure the given operator on a noiseless backend
    circ = transpile(state, noiseless_backend)
    result: Result = noiseless_backend.run(circ).result()
    noiseless_result = projective_measurement(result, operator)

    # 2. measure the given operator on a noisy backend
    circ = transpile(state, noisy_backend)
    result: Result = noisy_backend.run(circ).result()
    noisy_result = projective_measurement(result, operator)

    # 3. determine the corrected expectation value
    # calculate the w matrix with the given error probabilities
    _ = w_matrix(operator.N, error_probabilities)
    corrected: Expr = S(0)
    for correcting_operator in relevant_operators(operator):
        expectation = projective_measurement(result, correcting_operator)
        corrected += w_inverse_element(operator, correcting_operator) * expectation

    return BenchmarkResult(noisy=noisy_result, noiseless=noiseless_result, corrected=float(corrected))
