from typing import NamedTuple

from qiskit import transpile
from qiskit.providers.aer.backends.aerbackend import AerBackend
from qiskit.result.result import Result
from sympy import Expr, S

from expectation_value import expectation_value
from noise import ErrorProbabilities
from util import init_random_state, random_angles
from w import OrderedOperator, relevant_operators, w_inverse_element, w_matrix


class BenchmarkResult(NamedTuple):
    """The result of one call of the benchmark_mitigation procedure.

    This contains the expectation values for <psi|O|psi>, where O is a given
    operator and |psi> is a random state generated by the benchmark_mitigation
    procedure.
    """
    noiseless: float
    noisy: float
    corrected: float


def benchmark_mitigation(
        operator: OrderedOperator,
        noiseless_backend: AerBackend,
        noisy_backend: AerBackend,
        error_probabilities: ErrorProbabilities
) -> BenchmarkResult:
    """Produce some data to benchmark the error correction.

    We want to compare three cases:
        1. the (QM) expectation value of the given operator, measured on a
           noiseless backend
        2. the (QM) expectation value of the given operator, measured on a
           noisy backend
        3. the (statistical) expectation value of the error corrected operator,
           from measurements on a noisy backend.

    For this, we measure the given state in the computational basis on a
    noiseless and a noisy device.

    The first case is obtained by calculating the expectation value with
    respect to the given operator from the noiseless result, the second one
    from the noisy result. To obtain the third one, the measurements are
    interpreted with respect to the correcting operators and weights obtained
    by the w matrix.

    :param operator: the operator which expectation value should be determined.
    :param noiseless_backend: the noiseless backend to compare the correction.
    :param noisy_backend: the noisy backend to perform the actual measurements.
    :param error_probabilities: the bit-flip probabilities of each qubit.
    """
    # prepare a random state |psi> to be measured
    state = init_random_state(operator.N, angles=random_angles(operator.N))
    state.measure_all()

    # 1. measure the given operator on a noiseless backend
    circ = transpile(state, noiseless_backend)
    noiseless_result: Result = noiseless_backend.run(circ).result()
    noiseless = expectation_value(noiseless_result, operator)

    # 2. measure the given operator on a noisy backend
    circ = transpile(state, noisy_backend)
    noisy_result: Result = noisy_backend.run(circ).result()
    noisy = expectation_value(noisy_result, operator)

    # 3. determine the corrected expectation value
    # calculate the w matrix with the given error probabilities
    _ = w_matrix(operator.N, error_probabilities)
    corrected: Expr = S(0)
    for correcting_operator in relevant_operators(operator):
        expectation = expectation_value(noisy_result, correcting_operator)
        correcting_factor = w_inverse_element(operator, correcting_operator)
        corrected += correcting_factor * expectation

    result = BenchmarkResult(noisy=noisy, noiseless=noiseless,
                             corrected=float(corrected))
    return result
