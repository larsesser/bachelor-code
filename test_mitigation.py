from typing import NamedTuple

from qiskit import transpile
from qiskit.providers.aer.backends.aerbackend import AerBackend
from qiskit.result.result import Result
from sympy import Expr, S

from expectation_value import expectation_value
from noise import ErrorProbabilities
from ordered_operator import lexicographic_ordered_operators
from util import init_random_state, random_angles
from w import OrderedOperator, w_inverse_element, w_matrix


class BenchmarkResult(NamedTuple):
    """The result of one call of the benchmark_mitigation procedure.

    This contains the expectation values for <O>_\rho (noiseless),
    <O>_\tilde{\rho} (noisy) and the corrected expectation value constructed
    from <O>_\tilde{\rho} and the w^-1 matrix. O is a given operator and \rho
    is a random state generated by the benchmark_mitigation procedure.
    """
    noiseless: float
    noisy: float
    corrected: float


def benchmark_mitigation(
        operator: OrderedOperator,
        noiseless_backend: AerBackend,
        noisy_backend: AerBackend,
        error_probabilities: ErrorProbabilities
) -> BenchmarkResult:
    """Produce some data to benchmark the error correction.

    We want to compare three cases:
        1. The expectation value <O>_\rho of the given operator, measured on a
           noiseless backend.
        2. The expectation value <O>_\tilde{\rho} of the given operator,
           measured on a noisy backend.
        3. The corrected expectation value, constructed from measurements on
           the noisy backend and weighted with the w^-1 matrix.

    To achieve this, we construct a random state \rho and measure it on the
    noiseless backend and the noisy backend.

    :param operator: the operator which expectation value should be determined.
    :param noiseless_backend: the noiseless backend to compare the correction.
    :param noisy_backend: the noisy backend to perform the actual measurements.
    :param error_probabilities: the bit-flip probabilities of each qubit.
    """
    # prepare a random state to be measured
    state = init_random_state(operator.N, angles=random_angles(operator.N))
    state.measure_all()

    # 1. measure the state on a noiseless backend
    circ = transpile(state, noiseless_backend)
    noiseless_result: Result = noiseless_backend.run(circ).result()
    noiseless = expectation_value(noiseless_result, operator)

    # 2. measure the state on a noisy backend
    circ = transpile(state, noisy_backend)
    noisy_result: Result = noisy_backend.run(circ).result()
    noisy = expectation_value(noisy_result, operator)

    # 3. determine the corrected expectation value
    # calculate the w matrix with the given error probabilities
    _ = w_matrix(operator.N, error_probabilities)
    corrected: Expr = S(0)
    for correcting_operator in lexicographic_ordered_operators(operator.N):
        expectation = expectation_value(noisy_result, correcting_operator)
        correcting_factor = w_inverse_element(operator, correcting_operator)
        corrected += correcting_factor * expectation

    result = BenchmarkResult(noisy=noisy, noiseless=noiseless,
                             corrected=float(corrected))
    return result
